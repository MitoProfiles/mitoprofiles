---
title: "MitoSignatures"
author: "Isabel Duarte"
date: "2023-06-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warnings = FALSE, cache = TRUE)

library(here)
library(SummarizedExperiment)
library(tidyverse)

```

## Functions

```{r functions, eval=TRUE}

#### METADATA TABLE ####

# FUNCTION | Create a metadata table with sample ids, cancer status, organ, and metabolic rate

create_metadata <- function (input_data, cancer_yes_no) {
  # Create an empty table
  combined_metadata <- tibble()
  
  # Loop through each organ
  for (i in 1:length(input_data)) {
    # Extract the data for each organ
    organ_data <- input_data[[i]]
    
    # Extract the sample ID, cancer status, metabolic rate and organ values
    sample_id <- colnames(organ_data)[-1]
    organ <- gsub("\\d", "", names(input_data)[i])
    metabolic_rate <- if_else(organ %in% c("bladder", "skin", "colon"),
                              "low", "high" )
    cancer_status <- if_else( cancer_yes_no == "yes", 
                              "cancer", "non_cancer")
    
    # Create a temporary dataframe for the organ
    organ_df <- data.frame(sample_id = sample_id, 
                           cancer_status = cancer_status,
                           metabolic_rate = metabolic_rate,
                           organ = organ)
    
    # Append the organ dataframe to the combined dataframe
    combined_metadata <- rbind(combined_metadata, organ_df)
  }
  
  # Transform the relevant variables to factors
  combined_metadata %>%
    mutate(cancer_status = factor(cancer_status, levels=c("non_cancer", "cancer")),
           metabolic_rate = factor(metabolic_rate, levels=c("low", "high")),
           organ = factor(organ, levels=c("bladder",
                                          "colon",
                                          "skin",
                                          "brain",
                                          "kidney", 
                                          "liver"))) -> combined_metadata2
  
  # Return the metadata object for all organs and with variables as factors
  return(combined_metadata2)
}

```

## Load TCGA, GTEx, and MitoCarta data
```{r load_data, eval=TRUE}

## Install the mitocarta data package and load the mitocarta data
# remotes::install_github("MitoProfiles/MitoCarta")
mitocarta::mitocarta_data$A_Human_MitoCarta3 -> mitocarta_data

## Load RNA-seq datasets from TCGA and GTEx (big RDS files can be slow to load)
gtex_data <- readRDS(here("data/processed/gtex.RDS"))
tcga_data_se <- readRDS(here("data/processed/tcga_data_se.RDS"))

```

## About the RNA-seq protocols

### GTEx Methods

Reference | https://www.gtexportal.org/home/methods

GTEx Analysis Methods   
Updated on 08/20/2019   
Current Release: V8   

RNA-seq was performed using the Illumina TruSeq library construction protocol (**non-stranded**, polyA+ selection) .

RNA-seq Alignment | Alignment to the *human reference genome GRCh38/hg38* was performed using *STAR v2.5.3a*, based on the *GENCODE v26* annotation.

### TCGA Methods

Reference | https://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/Expression_mRNA_Pipeline

Introduction | The GDC mRNA quantification analysis pipeline measures gene level expression with   STAR as raw read counts. Subsequently the counts are augmented with several transformations including Fragments per Kilobase of transcript per Million mapped reads (FPKM), upper quartile normalized FPKM (FPKM-UQ), and Transcripts per Million (TPM). These values are additionally annotated with the gene symbol and gene bio-type. These data are generated through this pipeline by first **aligning reads to the GRCh38 reference genome** and then by quantifying the mapped reads. **To facilitate harmonization across samples, all RNA-Seq reads are treated as *unstranded* during analyses.**

mRNA Expression Workflow | The primary counting data is generated by STAR and includes a gene ID, **unstranded**, and stranded counts data. Following alignment, the raw counts files produced by STAR are augmented with commonly used counts transformations (FPKM, FPKM-UQ, and TPM) along with basic annotations as part of the RNA Expression Workflow. These data are provided in a tab-delimited format. **GENCODE v36** was used for gene annotation.
(...)
Note that the STAR counting results will **not count reads that are mapped to more than one different gene.** [Such] genes will likely display a value of zero.

### Conclusion

- Strandedness | Both GTEx and TCGA use **unstranded** library protocols.
Reference genome | Both GTEx and TCGA use **GRCh38/hg38** human reference genome for alignment.
- Gene annotation | **GTEx uses GENCODE v26** and **TCGA uses GENCODE v36**. THIS MUT BE CORRECTED!

These information are relevant to decide which data from the TCGA to use, since the STAR-counts workflow-type from the TCGAbiolinks retrieves 3 count types: unstranded, stranded_first, and stranded_second. 
Since the **GTEx counts are unstranded**, then the data to use from **TCGA must also be unstranded counts**. 

- Regarding the unmatched gene annotation version: We do not have free access to the raw reads files (or even BAM files), so we cannot re-map the reads to the same annotation.
Accordingly, we will compute differential gene expression between the different metabolic-rate organs in each dataset separately (GTEx, and TCGA), and them compare the results found for each dataset manually.
We will also merge both sets and evaluate, by PCA, if the sets have batch effects or if they seem to be safe to study together.


## TCGA | Get expression data and Create the sample metadata table

```{r tcga_exprs_metadata, eval=TRUE}
#
##
### Expression data | Gene counts
##
#

## Get dataframe with gene expression per organ for all TCGA datasets
tcga_data_clean <- list()

# Map dataset names to organ names
tcga_dataset_names <- c("bladder" = "TCGA_BLCA", 
                        "skin" = "TCGA_SKCM", 
                        "colon" = "TCGA_COAD",
                        "brain1" = "TCGA_GBM", 
                        "brain2" = "TCGA_LGG",
                        "liver1" = "TCGA_LIHC", 
                        "liver2" = "TCGA_CHOL",              
                        "kidney1" = "TCGA_KIRC", 
                        "kidney2" = "TCGA_KICH", 
                        "kidney3" = "TCGA_KIRP") 

# Loop over the datasets and separate each expression table per organ | Get the unstranded counts
for (tcga_dataset in tcga_dataset_names) {
  
  organ <- names(tcga_dataset_names[which(tcga_dataset_names == tcga_dataset)])
  
  SummarizedExperiment::assays(tcga_data_se[[tcga_dataset]])$unstranded %>%
    .[rowSums(.[]) > 0,] %>%   # remove rows with all zero values
    as_tibble(rownames = "gene_id") -> tcga_data_clean$counts[[organ]]
}

#
##
### Metadata
##
#

## Getting the Metadata table with organ_name, metabolic_rate, and cancer_status
create_metadata (input_data = tcga_data_clean$counts, cancer_yes_no = "yes") -> tcga_data_clean$metadata

#
##
### Combine TCGA count data for all organs
##
#

tcga_data_clean$combined_counts <- Reduce(function(x,y) full_join(x, y, by="gene_id"), tcga_data_clean$counts)

## Save the  RDS file with clean and formatted TCGA data | Slow step
saveRDS(tcga_data_clean, file = here("data/processed/tcga_data_clean.RDS"))

```


## GTEx | Get expression data and Create the sample metadata table

```{r gtex_exprs_metadata, eval=TRUE}
#
##
### Expression data | Gene counts
##
#
## Get dataframe with gene expression in TPMs per organ for all GTEx datasets
gtex_data_clean <- list()

# Map dataset names to organ names
gtex_dataset_names <- c( "brain" = "brain_cortex",
                         "skin1" = "skin_sun_exposed_lower_leg",
                         "skin2" = "skin_not_sun_exposed_suprapubic",
                         "liver" = "liver", 
                         "kidney1" = "kidney_medulla", 
                         "kidney2" = "kidney_cortex",
                         "bladder" = "bladder", 
                         "colon1" = "colon_sigmoid",
                         "colon2" = "colon_transverse")

# Loop over the datasets and separate each expression table per organ
for (gtex_dataset in gtex_dataset_names) {
  
  organ <- names(gtex_dataset_names[which(gtex_dataset_names == gtex_dataset)])
  
  gtex_data[[gtex_dataset]] %>%
    select(-id, -Description) %>%
    filter(rowSums(across(where(is.numeric))) != 0) %>%   # remove rows with all zero values
    dplyr::rename(gene_id = Name) -> gtex_data_clean$counts[[organ]]
}

#
##
### Metadata table
##
#

## Getting the Metadata table with organ_name, metabolic_rate, and cancer_status
create_metadata (input_data = gtex_data_clean$counts, cancer_yes_no = "no") -> gtex_data_clean$metadata

#
##
### Combine GTEx count data for all organs
##
#

gtex_data_clean$combined_counts <- Reduce(function(x,y) full_join(x, y, by="gene_id"), gtex_data_clean$counts)

## Save the  RDS file with clean and formatted GTEx data
saveRDS(gtex_data_clean, file = here("data/processed/gtex_data_clean.RDS"))

```

## Combine TCGA and GTEx datasets 

```{r combine_tcga_gtex_datasets, eval=TRUE}
#
##
### Combine TCGA and GTEx counts and metadata | NOT NEEDED ANYMORE
##
#

# Combine count data for TCGA and GETx
combined_counts_tcga_gtex <- full_join(tcga_data_clean$combined_counts,
                                    gtex_data_clean$combined_counts,
                                    by="gene_id")
# Combine metadata for TCGA and GTEx
combined_metadata_tcga_gtex <- bind_rows(tcga_data_clean$metadata,
                                         gtex_data_clean$metadata)

# Save the combined datasets rds file
saveRDS(combined_metadata_tcga_gtex, 
        file = here("data/processed/combined_metadata_tcga_gtex.RDS"))
saveRDS(combined_counts_tcga_gtex, 
        file = here("data/processed/combined_counts_tcga_gtex.RDS"))

```

## Combined GTEx and TCGA | PCA | Evaluate if read counts can be used together 

```{r pca, eval=TRUE}

# Because TCGA and GTEx were processed with different versions of gencode annotation  

#
##
### PCA analysis | Uncomment section if needed to recompute the PCA | SLOW STEP
##
#

# Remove NAs
na.omit(combined_counts_tcga_gtex) -> combined_counts_tcga_gtex_no_NAs

# Transform the data into a matrix and Transpose it
  # Because in a PCA the columns represent the variables (features)
  # and the rows represent the observations (samples)

gene_expression_matrix <- t(combined_counts_tcga_gtex_no_NAs[, -1])
colnames(gene_expression_matrix) <- combined_counts_tcga_gtex_no_NAs$gene_id

# Perform PCA | Slow step
pca_result <- prcomp(gene_expression_matrix,
                    center = TRUE,
                    scale. = FALSE) # cannot use scale true: "cannot rescale a constant/zero column to unit variance"

# Access the PCA results
pca_scores <- pca_result$x  # Principal component scores
pca_loadings <- pca_result$rotation  # Principal component loadings

# Create a dataframe with PC scores, patient id, and study
data.frame(PC1 = pca_scores[, 1],
           PC2 = pca_scores[, 2]) %>% 
  rownames_to_column(var="patient_id") %>%
  mutate(study = case_when(grepl("^TCGA", patient_id) ~ "TCGA",
                           grepl("^GTEX", patient_id) ~ "GTEX",
                           TRUE ~ NA_character_)) -> pca_scores_df

# Look at the results: PC1 vs PC2 scatter plot
ggplot(pca_scores_df, aes(x = PC1, y = PC2, color=study)) +
  geom_point() +
  xlab("PC1") +
  ylab("PC2") +
  ggtitle("PCA Plot | Combined TCGA and GTEx data")

# Save the pca results
saveRDS(pca_result, file=here("data/processed/combined_pca_result.RDS"))
saveRDS(pca_scores_df, file=here("data/processed/combined_pca_scores_df.RDS"))

```






